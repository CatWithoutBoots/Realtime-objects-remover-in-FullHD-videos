// (C) 1992-2018 Intel Corporation.                            
// Intel, the Intel logo, Intel, MegaCore, NIOS II, Quartus and TalkBack words    
// and logos are trademarks of Intel Corporation or its subsidiaries in the U.S.  
// and/or other countries. Other marks and brands may be claimed as the property  
// of others. See Trademarks on intel.com for full list of Intel trademarks or    
// the Trademarks & Brands Names Database (if Intel) or See www.Intel.com/legal (if Altera) 
// Your use of Intel Corporation's design tools, logic functions and other        
// software and tools, and its AMPP partner logic functions, and any output       
// files any of the foregoing (including device programming or simulation         
// files), and any associated documentation or information are expressly subject  
// to the terms and conditions of the Altera Program License Subscription         
// Agreement, Intel MegaCore Function License Agreement, or other applicable      
// license agreement, including, without limitation, that your use is for the     
// sole purpose of programming logic devices manufactured by Intel and sold by    
// Intel or its authorized distributors.  Please refer to the applicable          
// agreement for further details.                                                 

// Generated by Intel(R) HLS Compiler, Version 18.1.0 Build 625

`include "gmm_structures.svh"

/////////////////////////////////////////////////////////////////
// MODULE gmm_substract_internal
/////////////////////////////////////////////////////////////////
module gmm_substract_internal
(
   input logic clock,
   input logic resetn,
   // AVST snk
   input logic snk_valid,
   output logic snk_ready,
   input logic [175:0] snk_data,
   // AVST src
   output logic src_valid,
   input logic src_ready,
   output logic [175:0] src_data,
   input logic [7:0] d,
   input logic [7:0] bg_th,
   input logic [9:0] in_alpha,
   input logic [7:0] s
);
	// RGB888 data format
	typedef struct packed {
		logic[7:0] r, g, b;
	} rgb888_t;

    typedef struct packed {
		logic [7:0] data;
	} class_ac_int_3;

	typedef struct packed {
		logic [7:0] data;
	} class_ac_int_6;

	typedef struct packed {
		rgb888_t  data;
	} struct_rgb_t;

	typedef struct packed {
		logic [7:0] data;
	} class_ac_int_9;

	typedef struct packed {
		logic[7:0] w;
		logic[7:0] rgb_std;
		rgb888_t rgb_mean;
	} struct_cluster_t;

	typedef struct packed {
		class_ac_int_9  is_fg;
		struct_rgb_t  rgb_new;
		class_ac_int_6  u;
		class_ac_int_6  chm;
		class_ac_int_3  clusters_num;
		struct_cluster_t [2:0]  cluster;
	} struct_data_t;

	typedef struct {
		logic valid, sop, eop, ready;
		struct_data_t data;
	} gmm_bus_t;
	
	import gmm_structures::*;

    struct_data_t out_data, in_data;
	data_t in_gmm, out_gmm, pre_out_gmm;

    assign in_data = snk_data;
    assign src_data = out_data;
	
	always_comb begin
		in_gmm.clusters_num = in_data.clusters_num.data[1:0];
		in_gmm.chm = in_data.chm.data[5:0];
		in_gmm.u = in_data.u.data[5:0];
		in_gmm.rgb_new = in_data.rgb_new;
		in_gmm.is_fg = in_data.is_fg.data[0];
		for (int i = 0; i < 3; ++i) begin
			in_gmm.cluster[i].rgb_mean = in_data.cluster[i].rgb_mean;
			in_gmm.cluster[i].rgb_std = in_data.cluster[i].rgb_std[5:0];
			in_gmm.cluster[i].w = in_data.cluster[i].w;
		end
	end

	always_comb begin
		out_data = '0;
		out_data.clusters_num.data = {6'b0, out_gmm.clusters_num};
		out_data.chm.data[5:0] = {2'b0, out_gmm.chm};
		out_data.u.data[5:0] = {2'b0, out_gmm.u};
		out_data.rgb_new = out_gmm.rgb_new;
		out_data.is_fg = {7'b0, out_gmm.is_fg};
		for (int i = 0; i < 3; ++i) begin
			out_data.cluster[i].rgb_mean = out_gmm.cluster[i].rgb_mean;
			out_data.cluster[i].rgb_std = {2'b0, out_gmm.cluster[i].rgb_std};
			out_data.cluster[i].w = out_gmm.cluster[i].w;
		end
	end
	
	gmm_subtract gmm_subtract_inst(
		.d, 
		.bg_th,  
		.in_alpha, 
		.s,
		.u_max(8'd63),

		.clk(clock), .rst(~resetn),
		
		.snk_valid,
		.snk_data(in_gmm),
		.snk_ready,
		
		.src_ready,
		.src_valid,
		.src_data(out_gmm)
	);	
	
/*
    backpressure_machine #(
        .LATENCY(143), // editable, must be more than 1
        .DATA_EN(1),
        .DATA_WIDTH($bits(in_gmm))
    ) bm_0 (
        .clk(clock), .rst(~resetn),

        .snk_valid,
        .snk_data(in_gmm),
        .snk_ready,
        
        .src_ready,
        .src_valid,
        .src_data(pre_out_gmm)
    );*/

	/*// RGB888 data format
	typedef struct packed {
		logic[7:0] r, g, b;
	} rgb888_t;

    typedef struct packed {
		logic [7:0] data;
	} class_ac_int_3;

	typedef struct packed {
		logic [7:0] data;
	} class_ac_int_6;

	typedef struct packed {
		rgb888_t  data;
	} struct_rgb_t;

	typedef struct packed {
		logic [7:0] data;
	} class_ac_int_9;

	typedef struct packed {
		logic[7:0] w;
		logic[7:0] rgb_std;
		rgb888_t rgb_mean;
	} struct_cluster_t;

	typedef struct packed {
		class_ac_int_9  is_fg;
		struct_rgb_t  rgb_new;
		class_ac_int_6  u;
		class_ac_int_6  chm;
		class_ac_int_3  clusters_num;
		struct_cluster_t [2:0]  cluster;
	} struct_data_t;

	typedef struct {
		logic valid, sop, eop, ready;
		struct_data_t data;
	} gmm_bus_t;

    struct_data_t out_data, in_data;

    assign in_data = snk_data;
    assign src_data = out_data;


	always_comb begin
	   snk_ready = src_ready | ~src_valid;
	end 

    always_ff @(posedge clock or negedge resetn) 
        if (!resetn) begin
            src_valid <= '0;
            out_data <= '0;
        end
        else begin
            if (snk_valid)
                src_valid <= '1;
            else if (src_ready)
                src_valid <= '0;

            if (snk_valid && snk_ready) begin
                out_data <= in_data;
                out_data.cluster[0].rgb_mean.r <= in_data.rgb_new.data.r;
                out_data.cluster[0].rgb_mean.g <= in_data.rgb_new.data.g;
                out_data.cluster[0].rgb_mean.b <= in_data.rgb_new.data.b;
            end
		end

*/
endmodule

